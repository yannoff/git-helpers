#!/bin/bash
#
# Batch rebase script
# Rebase several branches on the current one
#

_usage(){
    local code=${1:-0}
    echo "Usage:"
    echo "    git batch-rebase --all"
    echo "    git batch-rebase branch1 [branch2 ... [branchN]]"
    exit ${code}
}

_printf(){
    local msg=${1}
    shift 1
    set -- "\033[01m${msg}\033[00m\n" "$@"
    printf "$@"
}

_exec(){
    local status
    printf "%s\n" "$*"
    echo -ne "\033[01;30m"
    $@
    status=$?
    echo -ne "\033[00m"
    return ${status}
}

[ "$#" -eq "0" ] && _usage

current=$(git branch | awk '($1 == "*") { print $2; }')

# If --all option was supplied, set all (except the current) branches as argument
[ "${1}" == "--all" ] && set -- $(git branch | awk '($1 != "*")' | xargs)

trap "git checkout -q ${current}; echo; echo -n 'Exiting...'; exit 0" SIGINT SIGTERM

for f in "$@"
do
    _printf "Rebasing %s onto %s" ${f} ${current} && \
    _exec git checkout -q ${f} && \
    sleep 2
    _exec git rebase -i ${current} && \
    _printf "Push rebased branch ? (y/f/N)" && \
    read r && \
    {
        case "${r}" in
            y|yes)
                _exec git push && \
                _printf "=> Pushed rebased branch"
                ;;
            f|force)
                _exec git push --force && \
                _printf "=> Force-pushed rebased branch"
                ;;
            *)
                _printf "=> Rebased branch not pushed"
        esac
    }
    _exec git checkout -q ${current}
done

_exec git checkout -q ${current}
